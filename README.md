# Предсказание типа почвы по имеющимся собранным данным, хранящимся в XLS файле, методом построения дерева решений.

---

# Использованные библиотеки:

OpenXLSX;

# Принцип работы программы

Данная программа реализует алгоритм поиска наилучшего разбиения для дерева решений, используя функции энтропии и прироста информации. Алгоритм основан на следующих принципах:

1. **Энтропия:**
Функция entropy вычисляет энтропию для данного набора меток. Энтропия используется для измерения неопределенности в системе. Чем выше энтропия, тем больше неопределенность.
Создание неупорядоченного множества уникальных меток. Здесь из переданного вектора меток labels создается неупорядоченное множество unique_labels, содержащее только уникальные метки;

Вычисление энтропии. Итерация по уникальным меткам и вычисление вклада каждой метки в энтропию. Для каждой уникальной метки в unique_labels (которые были рассчитаны ранее), код вычисляет вероятность p появления данной метки в исходном наборе. Затем выполняется вычисление вклада данной метки в общую меру неопределенности системы по формуле энтропии: p * log2(p), и это значение вычитается из общей энтропии entropy;

Возврат рассчитанного значения энтропии;

---

2. **Прирост информации:**
Функция information_gain принимает на вход вектор данных и целочисленный признак. Сначала он вычисляет общую энтропию набора данных с помощью функции энтропии. Затем он сортирует значения признака в порядке возрастания и перебирает все значения, кроме последнего. Для каждого значения он вычисляет разделенное значение как среднее значение текущего и следующего значений. Затем он разбивает набор данных на две части на основе значения разделения и вычисляет энтропию каждой части. Наконец, он вычисляет прирост информации как разницу между общей энтропией и взвешенной суммой энтропий двух частей. Функция возвращает максимальный прирост информации и значение разделения, которое привело к этому приросту.

---

3. **Получение признака с наилучшим информационным выигрышем:**
Функция find_best_feature находит наилучшую функцию для разделения набора данных на основе полученной информации. Функция принимает вектор данных в качестве входных данных и перебирает все объекты в наборе данных. Для каждой функции она вычисляет прирост информации с помощью функции information_gain и сравнивает его с текущим лучшим приростом. Если коэффициент усиления превышает текущий лучший коэффициент усиления, обновляется лучший коэффициент усиления и лучшая функция. Наконец, функция возвращает лучший признак, который привел к максимальному получению информации.

---

4. **Построение дерева решений:**
Сначала функция проверяет условия остановки. Если глубина дерева равна 0 или размер набора данных меньше 2, то эти условия остановки указывают на то, что нужно создать листовой узел дерева с предсказанным значением.

Если условия остановки не выполняются, функция продолжает выполнение и рассчитывает среднее значение переменной humus для каждого элемента вектора data. Это значение будет использоваться как предсказанный результат для листового узла.

После этого функция должна заняться делением данных по наилучшему признаку для разделения. Ваш код кажется неполным, и недостает этой части. Обычно процесс деления данных в дереве решений включает выбор наилучшего признака для разделения и разбиение данных на две (или более) ветви на основе этого признака.

В зависимости от результата этого деления, функция рекурсивно вызывает себя для каждой ветви дерева, уменьшая глубину на 1, пока не будут выполнены условия остановки.

---

5. **Прогнозирование значения гумуса для тестового вектора, используя обученного дерева принятия решений**

1. Сначала функция проверяет, имеет ли узел левого и правого потомков. Если узел является листовым (то есть у него нет потомков), то возвращается предсказанное значение, хранящееся в этом узле.

2. Если у узла есть потомки, функция проверяет, меньше ли значение тестовых данных по признаку node->feature, чем значение split_value текущего узла. Если это условие выполняется, то вызывается рекурсивный вызов функции "predict" с левым дочерним узлом в качестве аргумента. В противном случае вызывается рекурсивный вызов функции "predict" с правым дочерним узлом в качестве аргумента.
Это позволяет функции рекурсивно обойти дерево, используя тестовые данные для принятия решений о том, куда передвигаться по структуре дерева, пока не будет достигнут листовой узел, и предсказанное значение будет возвращено.

---
  